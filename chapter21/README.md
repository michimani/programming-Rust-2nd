21 章 マクロ
===

- 関数ではできないような言語拡張
- 関数とマクロでは動作機構が全く異なる
- より高度な **手続きマクロ** については参考文献を参照

## 基本

- マクロは `macro_roles!` で定義される
- マクロ定義時には `!` はつかない。実行するときにのみつく
- マクロの後ろの括弧の種類は何でも良い
  - `vec!` には `[]` , `assert_eq!` には `()` といったものはただの慣習
- マクロの定義はパターンマッチ式
- Webプログラミングで使用されるテンプレートと似たような感じ
- ただし、生成されるのは Rust のコード
- 自作したマクロ周りで変な挙動が出た場合は、まずはマクロを疑ったほうが良い
- `<[_]>` : 「なにかのスライス」型
- マクロをデバッグする方法 3 つ
  - `cargo build --verbose` を使う
    - rustc の起動オプションを確認
    - rustc を起動しているコマンドに `-Z unstable-option --pretty expanded` を追加して実行する
  - `log_syntax!()` を使う
    - `#![feature(log_syntax)]` つける
  - `trace_macro!(true);` をコードのどこかに書く

### json! マクロの実装

- マクロ内の再帰には、実装しようとしているマクロそのものを使うことができる
- 再帰の条件は `#[recursion_limit = "256"]` で指定できる
- 健全マクロ
  - マクロ内では一時変数を使用することができる
  - マクロ内外で同じ名前の変数を使用していたとしても、マクロ内の変数はコンパイル時に名前を変更してくれる (= 健全マクロ (hygienic macros))

### マクロのインポート・エクスポート

- 子モジュールでは自動的に使える
- 親モジュールへエクスポートするには `#[macros_use]` 属性を付与する
- `#[macros_export]` 属性が付与されたマクロは自動的に `pub` になり、他のアイテムと同様にパスで参照できる
- マクロ内の `$crate` は、マクロが定義されているクレートのルートモジュールへの絶対パス