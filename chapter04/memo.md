4 章 所有権と移動
===

- プログラミング言語のメモリ管理については下記の特徴があることが望ましい
  - プログラマが選んだタイミングでメモリが解放され、メモリ消費を制御できる
  - 解放済みのポインタへのアクセスがないこと。アクセスできると、プログラムのクラッシュやセキュリティホールにつながる
- ただし、この 2 点は相反しており、主要なプログラミング言語ではどちらかを諦める方針をとっている
  - ガベージコレクションを用いてメモリ管理をする「安全第一」方針
  - メモリ解放の責任をプログラマに委ねる「制御優先」方針
- Rust はどちらでもない

## 所有権

- すべての値は、その生存期間を決める唯一の所有者をもつ
- 所有者が解放された (**ドロップ (drop)** という) 場合、所有していた値もドロップされる
- `Vec<i32>` はスタックフレーム上に バッファ・容量・長さ を持ち、バッファはヒープ上に取られる
- `hoge: Vec<i32>` の `hoge` がドロップされたとき、ヒープ上のバッファも開放される
- `Box<T>` はヒープ上の `T` 型の値へのポインタ
- 所有者と所有される値はツリー構造を成す
- ツリー構造の root は変数
- 所有権の拡張
  - ひとつの値を別の所有者に **移動** できる
  - 整数や文字などの単純な型は Copy 型と呼ばれ、所有権のルールが適用されない
  - 参照カウントポインタ型 `Rc`, `Arc` を用いると、特定の条件下で複数の所有者を設定することができる
  - **参照** は所有権のないポインタで、 値への **参照の借用** が可能

## 移動

- 下記は値のコピーではなく **移動**
  - 変数への値の代入
  - 関数への値の引き渡し
  - 関数からの返り値の返却
- 値の移動で何が起こるか
  - ベクタを表わす変数 `s` が持つ値を `t` に移動する
  - `s` のスタックフレーム上のバッファ部分はヒープに置かれたバッファを指している
  - `t = s` としたとき、`t` のスタックフレーム上のバッファ部分が、もともと `s` が指していたヒープを指すようになる
  - `s` は未初期化状態となる
  - (図4-10)
- `Vec<T>` に対してインデックス指定して値を取得することはできない
  - `remove()`, `swap_remove()`, `replace()` などのメソッドを使う
  - メソッドの詳細は コレクション の章

## Copy 型

- ヒープ上にリソースを持たない型については、移動ではなく完全に独立したコピーとなる
  - `i32`, `f64`, `char` など
- ユーザ定義の構造体は、基本的に Copy 型ではない
- 構造体が持つフィールドがすべて Copy 型であれば、 `#[derive(Copy, Clone)]` を付与することで Copy 型にできる

## Rc と Arc (所有権の共有)

- Rc (reference count) と Arc (atomic reference count) はほぼおなじ
- Arc は複数のスレッド間で共有しても安全なようにできている
- Rc は高速な分、スレッド間での共有に対して安全ではない
- Rc ポインタ `Rc<T>` に対して `.clone()` を実行すると、 `T` の値はコピーされず、参照カウントがインクリメントされる
- クローンされた各変数は通常の所有権のルールが適用される
- 最後に残った Rc がドロップされたときに `T` もドロップされる
- Rc ポインタに所有される値は不変